<script defer src="deferred.js"/script>
<script async src="async.js"</script>
Атрибут defer заставляет браузер отложить выполнение сценария до тех пор
пока документ полностью не загрузится, будет проанализирован и станет гото
вым к манипуляциям. Атрибут async заставляет браузер запустить сценарий как
можно раньше, но не блокировать анализ документа во время загрузки сценария
- - -
Тип события
Строка, которая указывает вид происшедшего события. Например, тип
"mousemove" означает, что пользователь переместил указатель мыши. Тип
"keydown" означает, что пользователь нажал клавишу на клавиатуре. Тип
"load" означает, что завершена загрузка документа (или какого-то другого
ресурса) из сети. Поскольку тип события — всего лишь строка, ее
временами называют именем события, и мы действительно применяем это
имя для идентификации вида события, о котором идет речь.
- - -
document.removeEventListener("mousemove", handleMouseMove);
- - -
document.addEventListener("click", handleClick, {
  capture: true, // захватывающий обработчик
  once: true, // после срабатывания обработчик удалится (т.е. срабтоает 1 раз всего)
  passive: true // не будет работать preventDefault
});
- - - Аргумент обработчика событий
Обработчики событий вызываются с объектом Event в качестве единственного
аргумента. Свойства объекта Event предоставляют детали о событии.
• type. Тип события, которое произошло.
• target. Объект, в котором произошло событие.
• currentTarget. Для распространяемых событий это свойство представляет
особой объект, в котором был зарегистрирован текущий обработчик
событий.
• timestamp. Отметка времени (в миллисекундах), которая представляет аб
солютное время. Вы можете определить время, прошедшее между двумя
событиями, путем вычитания отметки времени первого события из отметки
времени второго события.
• isTrusted. Это свойство будет равно true , если событие было отправлено
самим веб-браузером, и false, если кодом JavaScript.

события мыши и указателя располагают свойствами clientX и clientY, которые
указывают координаты окна, где событие произошло.
- - -
target.onclick = function() { /* код обработчика */ };
- - -
Объект Document представляет содержимое окна
- - -
document.childNodes[0].childNodes[1]
document.firstChild.firstChild.nextSibling
- - -
let image = document.querySelector("main_image");
let url = image.src; // Атрибут src - это URL изображения.
image.id === "main__image" // => true; мы ищем изображение no id.

Аналогично с применением показанного ниже кода можно установить атрибуты
отправки формы элемента <form>:
let f = document.querySelector("form"); // Первый элемент <form> в документе.
f.action = "https://www.example.com/submit"; //Установить URL для отправки HTTP-запроса
f.method = "POST" ; // Установить тип 
- - - spinner
add() / remove() / contains() / toggle()
let spinner = document.querySelector("#spinner");
spinner.classList.remove("hidden");
spinner.classList.add("animated");
- - - insertAdjacentHTML()
Связанный метод insertAdjacentHTMLO в Element позволяет вставлять
строку произвольной HTML-разметки “по соседству” с указанным элементом.
Разметка передается методу во втором аргументе, а точный смысл “по соседству”
зависит от значения первого аргумента, которым должна быть строка с одним
из значений "beforebegin" (перед началом), "afterbegin" (после начала),
"beforeend" (перед концом) или "afterend" (после конца).
- - - textContent
let para = document.querySelector ("p"); // Первый элемент <p> в документе.
let text = para.textContent; // Получить текст абзаца.
para.textContent = "Hello World!"; // Изменить текст абзаца.
- - - Создание, вставка и удаление узлов
let paragraph = document.createElement("p"); // Создать пустой элемент <p>.
let emphasis = document.createElement("em"); // Создать пустой элемент <em>.
emphasis.append("WorId"); // Добавить текст в элемент <em>.
paragraph.append ("Hello ", emphasis, "!")// Добавить текст и <em> в <p>
paragraph.prepend("i"); // Еще добавить текст в начало <р>
paragraph.innerHTML // => "iHello <em>World</em>!”

// Найти заголовочный элемент с class="greetings".
let greetings = document.querySelector("h2.greetings");
// Вставить новый абзац и горизонтальную линию после этого
// заголовочного элемента.
greetings.after(paragraph, document.createElement("hr"));

// Создать копию абзаца и вставить ее после элемента с приветствием,
greetings.after(paragraph.cloneNode(true))

// Удалить элемент с приветствием из документа и заменить его
// абзацным элементом (перемещая абзац из текущего местоположения,
// если он уже был вставлен в документ).
greetings.replaceWith(paragraph);
// А теперь удалить абзац,
paragraph.remove();

// Предположим, что этот элемент "tooltip" имеет class="hidden" в НТМL Файле
// Вот как мы можем сделать его видимым:
document.querySelector("#tooltip").classList.remove("hidden");
// А так мы можем его скрыть:
document.querySelector("#tooltip").classList.add("hidden");

function displayAt(tooltip, х, у) { // установим координаты
  tooltip.style.display = "block";
  tooltip.style.position = "absolute";
  tooltip.style.left = '${x}px';
  tooltip.style.top = '${y}px';
}

// зададим стили элементу e
е.style.display = "block";
е.style. fontFamily = "sans-serif";
e.style.backgroundColor = "#ffffff";
e.style.marginLeft = "ЗООрх";
е.style.left = `${х0 + left_border + left_padding}px`;
e.style.margin = `${top}px ${right}px ${bottom}px ${left}px`;

// откопируем стили
// Копировать встроенные стили элемента е в элемент f :
f.setAttribute("style", e.getAttribute("style"));
// Или делать это следующим образом:
f.style.cssText = e.style.cssText;

- - - вычисляемый стиль
Чтобы получить вычисляемый стиль для элемента, необходимо вызвать
метод getComputedStyle () объекта Window
let title = document.querySelector("#sectionltitle");
let styles = window.getComputedStyle(title);
let beforeStyles = window.getComputedStyle(title, "::before");
Возвращаемым значением getComputedStyle() является объект
CSSStyleDeclaration, который представляет все стили, примененные к указанному
элементу

- - -Работа с таблицами стилей в сценариях
// Эта функция осуществляет переключение между "светлой" и "темной" темами
function toggleTheme() {
  let lightTheme = document .querySelector ("#light-theme");
  let darkTheme = document.querySelector("#dark-theme");
  if (darkTheme.disabled) { // В текущий момент светлая тема, переключить на темную.
  lightTheme.disabled = true;
  darkTheme.disabled = false;
} else { // В текущий момент темная тема, переключить на светлую.
  lightTheme.disabled = false;
  darkTheme.disabled = true;
}}


- - - Геометрия и прокрутка документов
Позиция элемента документа измеряется в пикселях CSS, причем координата
х увеличивается при движении вправо, а координата у увеличивается по мере
движения вниз.

Метод getBoundingClientRect() позволяет определять текущую позицию элемента в окне просмотра.
Иногда необходимо двигаться в другом направлении
и определять, какой элемент находится в заданном местоположении внутри окна
просмотра. Это можно делать с помощью метода elementFromPoint() объекта
Document. Вызывайте его с координатами х и у точки (используя коордиты 
окна просмотра, а не координаты документа: скажем, подойдут координаты
clientX и clientY события мыши). Метод elementFromPoint() возвращает
объект Element, который находится в указанной позиции. Алгоритм обнаружения
попаданий для выбора элемента точно не определен, но замысел метода
elementFromPoint() заключается в том, чтобы возвратить самый внутренний
(наиболее глубоко вложенный) и самый верхний (с наивысшим CSS-атрибутом
z-index) элемент в данной точке.

Метод scrollTo() объекта Window принимает координаты х и у точки (в координатах
документа) и устанавливает их как смещения линейки прокрутки. То
есть он прокручивает окно, чтобы указанная точка оказалась в левом верхнем
узлу окна просмотра. Если вы зададите точку, которая расположена слишком
близко к низу или слишком близко к правому краю документа, тогда браузер
переместит ее как можно ближе к левому верхнему углу, но не будет в состоянии
пройти весь путь до конца. Следующий код заставляет браузер выполнить
прокрутку так, чтобы стала видимой самая нижняя страница документа:

// Получить высоты документа и окна просмотра.
let documentHeight = document.documentElement.offsetHeight;
let viewportHeight = window.innerHeight;
// Выполнить прокрутку, чтобы в окне просмотра
// появилась последняя "страница".
window.scrollTo(0, documentHeight - viewportHeight);

Метод scrollBy() объекта Window похож на scrollTo(), но его аргументы
относительны и добавляются к текущей позиции прокрутки:
// Выполнять прокрутку на 50 пикселей вниз каждые 500 мс.
// Обратите внимание, что нет никакого способа отключить это!
setInterval(() => {scrollBy(0,50)}, 500);

Если вы хотите плавно прокручивать с помощью метода scrollTo () или
scrollBy(), тогда передавайте взамен двух чисел одиночный объектный аргумент:
window.scrollTo({
  left: 0,
  top: documentHeight - viewportHeight,
  behavior: "smooth"
});

Часто вместо прокрутки до числового местоположения в документе нам
нужно всего лишь прокрутить, чтобы определенный элемент в документе стал
видимым. Для этого можно вызвать метод scrollIntoView () на желаемом
HTML-элементе. Метод scrollIntoView() гарантирует, что элемент, на 
котором он вызван, будет виден в окне просмотра. По умолчанию он пытается
поместить верхний край элемента поблизости к верху окна просмотра.
Если в качестве единственного аргумента передается false, тогда метод пытается
поместить нижний край элемента в низ окна просмотра. При необходимости
браузер будет прокручивать окно просмотра и по горизонтали, чтобы сделать
элемент видимым.
Вы также можете передавать методу scrollIntoView() объект с установленным
свойством behavior:"smooth" для обеспечения плавной прокрутки.
Вы можете устанавливать свойство block для указания, где элемент должен
позиционироваться по вертикали, и свойство inline, чтобы указать, как он
должен позиционироваться по горизонтали, если требуется горизонтальная
прокрутка. Допустимые значения для обоих свойств — start, end, nearest и
center.

- - - размер окна просмотра
Для окон браузера размер окна просмотра выдается свойствами window.innerWidth 
и window.innerHeight. (Веб-страницы, оптимизированные для
мобильных устройств, часто применяют дескриптор <meta name="viewport">
в своих дескрипторах <head>, чтобы устанавливать желаемую ширину окна
просмотра для страницы.) Общий размер документа будет таким же, как размер
элемента <html>, т.е. document.documentElement. Чтобы получить ширину
и высоту документа, вы можете вызывать метод getBoundingClientRect()
объекта document.documentElement или воспользоваться свойствами
offsetWidth и offsetHeight объекта document.documentElement. Смещения
прокрутки документа внутри окна просмотра доступны как window.scrollX
и window.scrollY. Они являются свойствами, допускающими только чтение,
поэтому их нельзя устанавливать с целью прокрутки документа: взамен применяйте
метод window.scrollTo().
Что касается элементов, то ситуация чуть сложнее. В каждом объекте
Element определены следующие три группы свойств:

offsetWidth
offsetHeight
offsetLeft
offsetTop
offsetParent

clientWidth
clientHeight
clientLeft
clientTop

scrollWidth
scrollHeight
scrollLeft
scrollTop

- - - веб компоненты
<script type="module" srс="components/search-box.js">







