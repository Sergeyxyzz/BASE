Object.create() создает новый объект, используя в качестве его прототипа первый аргумент:
let o1 = Object .create ({х : 1, у: 2});// о1 наследует свойства х и у.
o1.x + o1.y // 3

Если вы хотите создать обыкновенный пустой объект (подобный объекту,
возвращаемому {} или new Object()), тогда передайте Object.prototype:
let оЗ = Object.create(Object, prtotype); //оЗ подобен {} или new Object ()
-------------
let author = book.author; //Получить свойство "author” объекта book
let name = author.surname; //Получить свойство "surname” объекта author
let title = book["main title"]; // Получить свойство "main title" объекта book
book.edition = 7; // Создать свойство "edition" объекта book
book ["main title"] = "ECMAScript"; // Изменить свойство "main title"

Когда применяется запись с квадратными скобками, мы говорим, что выражение
внутри квадратных скобок должно вычисляться в строку или, формулируя
более точно, выражение должно вычисляться в строку или значение, которое
может быть преобразовано в строку или значение Symbol
--------------------
let о = {}; // о наследует методы объекта от Object .prototype
o.х = 1 ; // и теперь имеет собственное свойство х.
let р = Object.create (о); //р наследует свойства от о и Object, prototype
p.у = 2; // и имеет собственное свойство у.
let q = Object .create (р); //q наследует свойства от р, о и . ..
q.z = 3; // ...Object.prototype и имеет собственное свойство z.
let f = q.toStringO ; //toString наследуется от Object .prototype
q.x + q.y // => 3; x и у наследуются от о и p
------------------------
let unitcircle = { r: 1 }; // Объект, от которого будет делаться наследование
let с = Object.create(unitcircle); // с наследует свойство r
с.х = 1; с.у = 1; // с определяет два собственных свойства
с.r = 2; / / с переопределяет свое унаследованное свойство
unitcircle.r // => 1: прототип не затронут
--------------------------
delete book.author; // Объект book теперь не имеет свойства author
delete book["main title"]; // А теперь он не имеет и свойства "main title"
----------------------------
// В строгом режиме все показанные ниже удаления генерируют ТуреЕггог, а не возвращают false
delete Object.prototype //=>false: свойство не допускает конфигурирование
var х = 1; // Объявление глобальной переменной
delete globalThis.x // => false: это свойство нельзя удалить
function f() {} // Объявление глобальной функции
delete globalThis.f // => false: это свойство тоже нельзя удалить
При удалении конфигурируемых свойств глобального объекта в нестрогом
режиме вы можете опускать ссылку на глобальный объект и указывать после
операции delete имя свойства:
globalThis.x = 1 ; // Создать конфигурируемое свойство глобального объекта (никаких let или var)
delete х // => true: это свойство можно удалить

Однако в строгом режиме операция delete генерирует SyntaxError, если
ее операндом оказывается неуточненный идентификатор вроде х, и вы должны
обеспечить явный доступ к свойству:
delete х; // SyntaxError в строгом режиме
delete globalThis.x; // Это работает
-------------------------------
let о = { х : 1 };
"х in о // => true: о имеет собственное свойство "х"
"у" in о // => false: о не имеет свойства "у"
"toString" in о // => true: о наследует свойство toString
Метод The hasOwnProperty () объекта проверяет, имеет ли данный объект
собственное свойство с заданным именем. Для унаследованных свойств он возвращает false :
let о = {х: l};
о.hasOwnProperty ("х") // => true: о имеет собственное свойство х
о.hasOwnProperty ("у") // => false: о не имеет свойства у
о.hasOwnProperty ("toString”) // => false: toString - унаследованное свойство
------------------------------
let о = {х: 1, у: 2, z: 3}; // Три перечислимых собственных свойства
о.propertylsEnumerable("toString") // => false: не перечислимое
for (let p in о) { // Проход в цикле по свойствам
  console.log(р); // Выводится х, у и z, но не toString
}
-------------------------------
Чтобы избежать перечисления унаследованных свойств посредством for/in, вы можете поместить внутрь тела цикла явную проверку:
for (let р in о) {
  if (!o.hasOwnProperty(р)) continue; // Пропускать унаследованные
  // свойства
}
for (let р in о) {
  if (typeof о[р] === "function”) continue; // Пропускать все методы
}
------------------------------
В качестве альтернативы использованию цикла for/in часто легче получить массив имен свойств для объекта и затем проходить по этому массиву в цикле
for/of. Есть четыре функции, которые можно применять для получения массива имен свойств.
• Функция Object.keys() возвращает массив имен перечислимых собственных свойств объекта. Она не включает не перечислимые свойства, унаследованные свойства или свойства с именами, представленными посредством значений Symbol (см. подраздел 6.10.3).
• Функция Object.getOwnPropertyNames() работает подобно Object.keys(), но возвращает массив также имен не перечислимых собственных свойств при условии, что их имена представлены строками.
• Функция Object.getOwnPropertySymbols() возвращает собственные свойства, имена которых являются значениями Symbol, перечислимые они или нет.
• Функция Reflect.ownKeys() возвращает имена всех собственных свойств, перечислимых и не перечислимых, представленных как строками, так и значениями Symbol. 
------------------------------
Необходимость копирования свойств одного объекта в другой — обычная
операция в программах JavaScript. Ее легко реализовать с помощью такого кода:
let target = {х: 1}, source = {у: 2, z: 3};
for (let key of Object.keys(source)) {
  target[key] = source[key];
}
target // => {x: 1, y: 2, z: 3}
--------------------------------
let х = 1, у = 2;
let о = { х, у };
о.х + о.у // => 3
--------------------------------
let position = ( х: 0, у: 0 };
let dimensions = { width: 100, height: 75 };
let rect = { ...position, ...dimensions };
rect.x + rect.у + rect.width + rect.height // => 175
--------------------------------