let a = ["а", "b", "с"]; // Массив, который мы хотим скопировать
let b = []; // Отдельный массив, куда мы будем копировать
for (let i = 0; i < a. length; i++) { // Для каждого из всех индексов
  b[i] = a[i]; // Копировать элемент а в b
}
let с = Array.from(b); // В ES6 копируйте массивы с помощью Array.from()

Подобным образом при желании сравнить два отдельных объекта или массива
мы обязаны сравнивать их свойства или элементы. В приведенном ниже
коде определяется функция для сравнения двух массивов:
function equalArrays (а, b) {
if (а === b) return true; // Идентичные массивы равны
if (a.length !== b.length) return false; //Массивы разного размера не равны
for (let i = 0; i < a.length; i++) {  // Цикл по всем элементам
  if (a[i] !== b[i]) return false; //Если любые элементы отличаются, то массивы не равны
)
  return true; // Иначе они равны
}
---------REDUCE-----------
let а = [1,2,3,4,51;
a.reduce ((х,у) => х+у, 0) // => 15; сумма значений
a.reduce((х,у) => х*у, 1) // => 120; произведение значений
a.reduce ((х,у) => (х > у) ? х : у) // => 5; наибольшее из значений

Метод reduceRight () работает в точности как reduce (), но обрабатывает
массив от самого высокого индекса до самого низкого (справа налево)
---------------------------
Выравнивание массивов с помощью
flat() и flatMap()
В ES2019 метод f l a t () создает и возвращает новый массив, содержащий те
же самые элементы, что и массив, на котором он вызывался, но любые элементы,
являющиеся массивами, в результирующем массиве будут “выровненными”.
Вот пример:
[1, [2, 3 ]].flat() // => [1, 2, 3]
[1, [2, [3]]].flat() // => [1, 2, [3]]
В случае вызова без аргументов метод f l a t () выравнивает один уровень
вложения. Элементы первоначального массива, которые сами представляют
собой массивы, выравниваются, но элементы этих массивов не выравниваются.
Если вы хотите выровнять больше уровней, тогда передайте методу f l a t ()
число:
let а = [1, [2, [3, [ 4 ]]]] ;
a.flat(1) // => [1, 2, [3, [4]]]
a.flat(2) // => [1, 2, 3, [4]]
a.flat(3) // => [1, 2, 3, 4]
a.flat(4) // => [1, 2, 3, 4]
-------------------------
let phrases = ["hello world", "the definitive guide"];
let words = phrases, flatMap (phrase => phrase.split (" "));
words // => ["hello", "world", "the", "definitive", "guide"];
------concat----------------------
let a — [1/2/3]/
a.concat(4, 5) // => [1,2,3,4,5]
a.concat ([4/5] / [6,7]) // => [1,2,3,4,5,6,7]; массивы выравниваются
a.concat (4, [5, [6,7] ]) // => [1,2,3,4,5, [6,7] ]; но не вложенные массивы
а //->[1,2,3]; исходный массив остается немодифицированным
-------------------------------------
let stack = []; // stack == [] •
stack.push (l,2); / / stack == [1,2];
stack.pop() ; // stack == [1]; возвращается 2
stack.push(3); // stack == [1,3]
stack.pop(); // stack == [1]; возвращается 3
stack.push([4,5]); / / stack == [1,[4 ,5]]
stack.pop() // stack == [1]; возвращается [4,5]
stack.pop(); // stack == []; возвращается 1

pop и push работают с конца массива
shift и unshift работают с начала массива
---------SLICE----------------------
let а = [1,2,3,4,5] ;
a.slice(0,3); // Возвращается [1,2,3]
a.slice(3); // Возвращается [4,5]
a.slice(1,-1); // Возвращается [2,3,4]
a.slice (-3,-2); // Возвращается [3]
-----------SPLICE--------------------
Метод splice  способен удалять элементы из массива, вставлять новые элементы
в массив или выполнять оба действия одновременно. Индексы элементов
массива, находящихся после точки вставки или удаления, должным образом увеличиваются
или уменьшаются, так что они остаются смежными с остатком массива.
Первый аргумент splice() задает позицию в массиве, где начинается вставка
и/или удаление. Второй аргумент указывает количество элементов, которые требуется
удалить из (отщепить от) массива. (Обратите внимание, что это еще одно
отличие между методами splice() и slice(). Во втором аргументе slice()
передается конечная позиция, а во втором аргументе splice() — длина.) Если
второй аргумент опущен, тогда удаляются все элементы массива от начального
элемента и до конца массива. Метод splice() возвращает массив с удаленными
элементами или пустой массив, если элементы не были удалены. 
let а = [1,2,3,4,5,6,7,8];
a.splice(4) // => [5,6,7,8]; а теперь [1,2,3,4]
a.splice(l,2) // => [2,3]; а теперь [1,4]
a.splice(l,l) // => [4]; а теперь [1]

Первые два аргумента splice() указывают, какие элементы массива подлежат
удалению. За этими аргументами может следовать любое количество дополнительных
аргументов, задающих элементы, которые должны быть вставлены в
массив, начиная с позиции, указанной в первом аргументе. Вот пример:

let а = [1,2,3,4,5];
a.splice(2,0,"а","Ь") // => []; а теперь [1,2,"а","b",3,4,5]
а.splice(2,2,[1,2],3) // => ["a","b"]; а теперь [1,2,[1,2],3,3,4,5]
----------------FILL----------
Метод fill() устанавливает элементы массива или среза массива в указанное
значение. Он видоизменяет массив, на котором вызывается, и также возвращает
модифицированный массив: 
let а = new Array (5); // Начать с массива без элементов длиной 5
a.fill(0) // => [0,0,0,0,0]; заполнить массив нулями
a.fill(9, 1) // => [0,9,9,9,9]; заполнить значениями 9, начиная с индекса 1
a.fill(8,2,-1) // => [0,9,8,8,9]; заполнить значениями 8 по индексам 2, 3
------------COPYWITHIN------------
Метод copyWithin () копирует срез массива в новую позицию внутри массива.
let а = [1,2,3,4,5] ;
a.copyWithin(1) // => [1,1,2,3,4]: копировать элементы массива в позиции, начиная с первого
a.copyWithin(2,3,5) и => [1,1,3,4,4] : копировать последние 2 элемента по индексу 2
a.copyWithin(0,-2) // => [4,4,3,4,4] : отрицательные смещения тоже работают
-----------------INDEXOF--------------
let а = [0,1,2,1,0];
a.indexOf (1) // => 1: а[1] равно 1
a.lastlndexOf(1) // => 3: а[3] равно 1
a.indexOf(3) // => -1: нет элементов со значением 3

Метод indexOf() производит поиск в массиве с начала до конца, а метод lastIndexOf() — с конца до начала:
------------INCLUDES-----------------
Метод includes() из ES2016 принимает единственный аргумент и возвращает
true, если массив содержит значение аргумента, или false в противном
случае.

let a = [1, true, 3, NaN];
a.includes(true) // => true
a.includes(2) // => false
a.includes(NaN) // => true
a.indexOf(NaN) // => -1; indexOf не может отыскивать NaN
----------SORT-------------------
let а = [33, 4, 1111, 222];
a.sort(); // а == [1111, 222, 33, 4]; алфавитный порядок
a.sort(function(а,b) { // Передать функцию сравнения
  return a-b; //Возвращает число<0,0 или > 0 в зависимости от порядка
}); // а == [4, 33, 222, 1111]; числовой порядок
a.sort((a,b) => b-а); //а == [1111, 222, 33, 4]; обратный числовой порядок
-----------JOIN--------------
join() преобразует все элементы массива в строки и выполняет их
конкатенацию, возвращая результирующую строку.
let а = [1, 2, 3]; 
a.join() // => "1,2,3"
a.join(" ") // => "1 2 3"
a.join("") // => "123"
let b = new Array(10); // Массив с длиной 10 без элементов
b.join("-") // => "---------": строка из 9 дефисов

Как и все объекты JavaScript, массивы метод toString(). Для массива он
работает подобно методу join(), вызываемому без аргументов:

[1,2,3].toString() // => "1,2,3”
["a", "b", "с"] .toString() // => "a,b,с"
[1, [2, "с"]].toString() // => "1,2,с"
----- ---- -----
let а = {"0": "а", "1": "b", "2": "с", length: 3}; // Объект,похожий на массив
Array.prototype.join.call(a, "+") // => "a+b+c”
Array.prototype.map.call(a, x => x.toUpperCase()) // => ["А","В","C"]
Array.prototype.slice.call(a, 0) // => ["a","b","с"): копирование в подлинный массив
Array.from(a) // => ["a", "b", "с"] : более легкое копирование







