/AHTML/; // Соответствует буквам Н Т М L в начале строки

/[1-9][0-9]*/; // Соответствует отличной от нуля цифре,за которой следует любое количество цифр

/\bjavascript\b/i; // Соответствует "javascript” как слову,нечувствительно к регистру символов

Объекты RegExp определяют ряд полезных методов, а строки имеют методы,
которые принимают аргументы RegExp, например:

let text = "testing: 1, 2, 3"; // Пример текста
let pattern = /\d+/g; // Соответствует всем вхождениям одной или большего количества цифр
pattern.test(text) // => true: есть совпадение
text.search(pattern) // => 9: позиция первого совпадения тк отсчет с нуля и цифра 1 является 9ой по счету
text.match(pattern) // => ["1", "2", "3"]: массив всех совпадений
text.replace(pattern, "#") // => "testing: #, #, #"
text.split(/\D+/) // => ["","1","2","3"]; разбиение по нецифровым символам
-----------------------
^ $ . * + ? = ! : | \ / () [ ] { } // особые символы

если вы хотите включить в регулярное выражение лю-
бой из перечисленных выше символов пунктуации буквально, то должны предварить
его символом \.

^ - Объект RegExp вида /[^abc]/ соответствует любому одному символу, отличающемуся от а,b и с.

Чтобы соответствовать любому одному символу
нижнего регистра из алфавита Latin, применяйте /[a—z]/, а для соответствия любой букве или цифре из алфавита Latin используйте / [a-zA-ZO-9] /.

\s соответствует символу пробела, символу табуляции и любому другому пробельному символу Unicode; 
\S соответствует любому символу, который НЕ является пробельным символом Unicode.

Обратите внимание, что специальные управляющие последовательности классов
символов могут применяться внутри квадратных скобок. \s соответствует любому
пробельному символу, a \d — любой цифре, поэтому /[\s\d]/ соответствует
любому одному пробельному символу или цифре.
---------------
[...] Любой один символ, находящийся между квадратными скобками
[^...] Любой один символ, не находящийся между квадратными скобками
. Любой символ за исключением символа новой строки или другого разделителя
строк Unicode. Или если RegExp использует флаг s, тогда точка
соответствует любому символу, в том числе разделителям строк
\w Любой символ слов ASCII. Эквивалентно [a-z A-Z 0-9 _]
\W Любой символ, который не является символом слов ASCII. Эквивалентно [^a-z A-Z 0-9 _]
\s Любой пробельный символ Unicode
\S Любой символ, не являющийся пробельным символом Unicode
\d Любая цифра ASCII. Эквивалентно [0-9]
\D Любой символ, отличающийся от цифры ASCII. Эквивалентно [^0-9]
[\b] Буквальный забой (особый случай)
-----------------
С помощью изученного до сих пор синтаксиса регулярных выражений вы
можете описать число из двух цифр как /\d\d/ и число из четырех цифр как /\d\d\d\d/
--------------------
{n,m} Соответствует предшествующему элементу, по крайней мере, n раз, но не более m раз
{n,} Соответствует предшествующему элементу n или больше раз
{n} Соответствует в точности n вхождениям предшествующего элемента
? Соответствует нулю или одному вхождению предшествующего элемента. То есть предшествующий элемент необязателен. Эквивалентно {0,1}
+ Соответствует одному или большему количеству вхождений предшествующего элемента. Эквивалентно {1,}
* Соответствует нулю или большему количеству вхождений предшествующего элемента. Эквивалентно {0,}

примеры:
let r = /\d{2,4}/; // Соответствует цифрам в количестве от двух до четырех
r = /\w{3}\d?/; // Соответствует в точности трем символам слов и необязательной цифре
r = /\s+java\s+/; // Соответствует "java" с одним и более пробелов до и после
r = /[^(]*/; // соответствует нулю или большему количеству символов, которые не являются открывающими круглыми скобками
------------------------
Грамматика регулярных выражений включает специальные символы для указания
альтернатив, группирования подвыражений и ссылки на предшествующие
подвыражения. Символ | отделяет альтернативы друг от друга. Скажем 
/ab|cd|ef/ соответствует строке "ab" или строке "cd" или строке "ef".
А шаблон /\d{3}|[a-z]{4}/ соответствует либо трем цифрам, либо четырем
буквам нижнего регистра.
------------------
| // Чередование: соответствует либо подвыражению слева, либо подвыражению
справа
(...) // Группирование: группирует элементы в единое целое, которое может использоваться с *, +, ?, | и т.д. Также запоминает символы, которые соответствуют этой группе, для применения в последующих ссылках
(?:...) // Только группирование: группирует элементы в единое целое, но не запоминает символы, которые соответствуют этой группе
\n // Соответствует тем же символам, которые дали совпадение, когда впервые
сопоставлялась группа номер n. Группы — это подвыражения внутри
(возможно вложенных) круглых скобок. Номера назначаются группам путем
подсчета левых круглых скобок слева направо. Группы, сформированные с
помощью (?:, не нумеруются
--------------------
Для именования группы применяйте (?<...> вместо ( и укажите имя между
угловыми скобками. Скажем, следующее регулярное выражение можно
использовать для проверки формата последней строки почтового адреса в
США:
/(?<city>\w+) (?<state>[A-Z]{2}) (?<zipcode>\d{5})(?<zip9>-\d{4})?/
----------------
чтобы найти слово "JavaScript" в отдельной строке, вы можете
применить регулярное выражение /^JavaScript$/.

Если вы хотите искать "Java" как отдельное слово (не как префикс в "JavaScript"), тогда можете опробовать
шаблон /\sJava\s/ ,

Скажем, шаблон /Java(?!Script)([A-Z]\w*)/ соответствует слову “Java”, за которым идет заглавная буква и любое количество
дополнительных символов слов ASCII при условии, что за словом “Java” не
находится “Script”.
-----------------
^ // Соответствует началу строки или при наличии флага m началу линии в строке
$ // Соответствует концу строки или при наличии флага m концу линии в строке
\b //  Соответствует границе слова, т.е. позиции между символом \w и символом \W
либо между символом \w и началом или концом строки. (Тем не менее, имейте в виду, что [\Ь] соответствует символу забоя.)
\B // Соответствует позиции не в границе слова
(?=p) // Утверждение положительного просмотра вперед. Требует, чтобы последующие символы соответствовали шаблону р, но не включает их в найденное соответствие
(?!р) // Утверждение отрицательного просмотра
-----------FLAGS--------------
• g. Флаг g указывает, что регулярное выражение является “глобальным”, т.е.
мы намерены его использовать для нахождения всех совпадений внутри
строки, а только первого совпадения. Флаг g не изменяет способ сопоставления
с образцом, но, как будет показано позже, он изменяет поведение
метода match() класса String и метода ехес() класса RegExp во многих
важных аспектах.
• i. Флаг i указывает, что сопоставление с образцом должно быть нечувствительнымк регистру.
• m. Флаг m указывает, что сопоставление с образцом должно выполняться
в “многострочном” режиме. Он говорит о том, что объект RegExp будет
применяться с многострочными строками, а якоря ^ и $ должны соответствовать
началу и концу строки плюс началу и концу индивидуальных линий
внутри строки.
• s. Подобно m флаг s также полезен при работе с текстом, который включает
символы новой строки. Обычно точка (.) в регулярном выражении
соответствует любому символу кроме разделителя строк. Однако когда
используется флаг s, точка будет соответствовать любому символу, в том
числе разделителям строк. Флаг s был добавлен к JavaScript в ES2018 и по состоянию на начало 2020 года он поддерживается в Node, Chrome, Edge ц
Safari, но не в Firefox.
• u. Флаг u означает Unicode и заставляет регулярное выражение соответствовать
полным кодовым точкам Unicode, а не 16-битным значениям. флаг
u был введен в ES6, и вы должны выработать привычку применять его во
всех регулярных выражениях, если только не существует веская причина
не поступать так. Если вы не используете этот флаг, тогда ваши объекты
RegExp не будут нормально работать с текстом, содержащим эмотиконы и
другие символы (включая многие китайские иероглифы), которые требуют
более 16 бит. В отсутствие флага и символ . соответствует любому одному
16-битному значению UTF-16. Тем не менее, при наличии флага и символ .
соответствует одной кодовой точке Unicode, в том числе содержащей свыше
16 бит. Установка флага и в объекте RegExp также позволяет применять
новую управляющую последовательность \u{...} для символа Unicode и
делает возможной запись \р{...} для классов символов Unicode.
• y. Флаг y указывает на то, что регулярное выражение является “липким” и
должно совпадать в начале строки или на первом символе, который следует
за предыдущим соответствием. При использовании с регулярным выражением,
предназначенным для поиска одиночного совпадения, флаг у фактически
трактует это регулярное выражение так, как если бы оно начиналось
с А с целью его прикрепления к началу строки. Этот флаг более полезен с
регулярными выражениями, которые применяются многократно для поиска
всех совпадений внутри строки. В таком случае он инициирует специальное
поведение метода match() класса String и метода ехес() класса
RegExp, чтобы обеспечить прикрепление каждого последующего совпадения
к позиции в строке, в которой закончилось последнее совпадение.

-----------МЕТОДЫ (ВСЕГО 4)-----------
search()
Строки поддерживают четыре метода, которые используют регулярные выражения.
Метод search() — самый простой из них. Он принимает аргумент с
регулярным выражением и возвращает либо символьную позицию начала первой
совпадающей подстроки, либо -1, если совпадения не обнаружены:
"JavaScript".search(/script/ui) // => 4
"python".search(/script/ui) // => -1
Метод search() не поддерживает глобальный поиск; он игнорирует флаг g в своем
аргументе с регулярным выражением.

replace() 
поиск и замена
// Независимо от того, как употребляются заглавные буквы, заменить строку корректным вариантом
text.replace(/javascript/gi, "JavaScript");
- - - - - -
// Цитата выглядит как кавычка, за которой следует любое количество
// символов, отличающихся от кавычек (их мы захватываем), и затем
// еще одна кавычка.
let quote = /"([^"]")"/g;
// Заменить прямые кавычки типографскими, оставив
// прежним цитируемый текст (хранящийся в $1) .
'Не said "stop"'.replace(quote, '«$1»') // => 'He said «stop»'
- - -
let quote = /"(?<quotedText>[^"]*)"/g;
'Не said "stop"'.replace(quote, '«$<quotedText>»') // => 'He said «stop»'

match()
Он принимает в своем единственном аргументе
регулярное выражение (или преобразует значение аргумента в регулярное
выражение, передавая его конструктору RegExp ()) и возвращает массив, который
содержит результаты сопоставления или null, если совпадения не найдены.
Если в регулярном выражении установлен флаг g, тогда метод возвращает
массив всех совпадений, обнаруженных в строке. Вот пример:
"7 plus 8 equals 15".match(/\d+/g) // => ["7", "8", "15"]

Если в регулярном выражении флаг g не установлен, то метод match() не
выполняет глобальный поиск; он просто ищет первое совпадение.

замэтчим урл
let url = /(?<protocol>\w+):\/\/(?<host>[\w.]+)\/(?<path>\S*)/;
let text = "Visit my blog at http://www.example.com/~david";
let match = text.match (url);
match[0] // => "http://www.example.com/~david"
match.input // => text
match.index // => 17
match.groups.protocol // => "http"
match.groups.host // => "www.example.com"
match.groups.path // => "~david"
- - - - - -
matchAll()
метод matchAll() предлагает самый легкий и универсальный способ прохода по всем совпадениям
внутри строки. Вот как можно применять matchAll() для прохода в цикле
по словам в строке текста:
// Один или большее количество алфавитных символов Unicode
// между границами слов
const words = /\b\p{Alphabetic}+\b/gu; 
const text = "This is a nanve test of the matchAll() method.";
for(let word of text.matchAll(words)) {
  console.log(`Found '${word[0]}' at index ${word.index}.`);
}
- - - - - -
split()
split() разбивает строку, на которой вызывается, на массив подстрок, используя аргумент в качестве разделителя.
"123,456,789".split(",") // => ["123", "456", "789"]

Метод split() также может принимать в своем аргументе регулярное выражение,
что позволяет указывать более общие разделители. Ниже мы вызываем
его с разделителем, который включает произвольное количество пробельных символов с обеих сторон
"1,2,3,\n4,5".split(/\s*,\s*/) // => ("1", "2", "3", "4", "5"]

Удивительно, но если вы вызовите split() с разделителем RegExp и регулярное
выражение содержит захватывающие группы, то текст, который соответствует
захватывающим группам, будет включен в возвращаемый массив.

const htmlTag = /<([^>]+)>/; // Символ <, за которым следует один или больше символов, отличающихся от >, и затем символ >
"Testing<br/>1,2,3".split(htmlTag) // => ["Testing", "br/", "1,2,3"]
-------------КЛАСС REGEXP----------
let exactMatch = /JavaScript/;
let caselnsensitive = new RegExp (exactMatch, "i");





