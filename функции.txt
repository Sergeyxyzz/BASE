uniqueInteger.counter = 0;
// При каждом вызове эта функция возвращает отличающееся целое число.
// Она использует собственное свойство для запоминания следующего
// возвращаемого значения,
function uniquelnteger () {
  return uniquelnteger.counter++; // Возвратить и инкрементировать свойство counter
}
uniquelnteger() // => 0
uniquelnteger() // => 1
---------------------------
// Вычисляет факториалы и кеширует результаты как свойства самой функции
function factorial(n) {
  if (Number.islnteger(n) && n > 0) {//Только положительные целые числа
    if (!(n in factorial)) {//Если кешированный результат отсутствует 
      factorial[n] = n * factorial(n-1); //  Вычислить и кешировать его
    }
      return factorial[n]; // Возвратить кешированный результат
    } else {
      return NaN; // Если входные данные недопустимы
    }
}
factorial[1] = 1; // Инициализировать кеш для хранения этого базового значения
factorial(6) // => 720
factorial[5] // => 120; вызов выше кеширует это значение
-------------------------------
function counter() {
  let n = 0;
  return {
    count: function() { return n++ },
    reset: function() { return n = 0 }
  }
}

let c = counter(), d = counter(); // создали 2 счетчика
c.count() // 0
d.count() // 0: счетчики независимы
c.reset(); // методы reset() и count() разделяют состояние
c.count() // 0: потому что мы сбросили c
d.count() // 1: d не сбрасывается
-------------GET SET--------------------------
в следующем коде демонстрируется работа метода addPrivateProperty ()
let о = {}; // Пустой объект
// Добавить методы доступа к свойству getName () и setName () .
// удостовериться, что разрешены только строковые значения.
addPrivateProperty (о, "Name", х => typeof х === "string");
o.setName ("Frank"); // Установить значение свойства
o.getName () // => "Frank"
о.setName (0); // !TypeError: попытка установки значения неправильного типа
-------------------------------
Методы c a l l () и a p p ly () позволяют косвенно вызывать (см. подраздел
8.2.4) функцию, как если бы она была методом какого-то другого объекта.
Первым аргументом в c a l l () и ap p ly () является объект, на котором должна
вызываться функция; он представляет контекст вызова и становится значением
ключевого слова t h i s внутри тела функции. Чтобы вызвать функцию f () как
метод объекта о (без аргументов), вы можете использовать либо c a l l (), либо
apply():
f.call(о);
f.apply(о);
Любая из двух строк подобна следующему коду (где предполагается, что объект
о не имеет свойства по имени m):
o.m = f; // Сделать f временным методом о
о.m(); // Вызвать его без аргументов
delete o.m; // Удалить временный метод


